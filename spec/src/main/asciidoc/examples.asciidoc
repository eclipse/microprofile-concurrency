//
// Copyright (c) 2018 Contributors to the Eclipse Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[examples]]
== MicroProfile Concurrency Examples

This section includes some additional examples of spec usage.

=== Contextualize a new CompletableFuture and all dependent stages

[source, java]
----
    executor = ManagedExecutor.builder()
                   .cleared(ThreadContext.TRANSACTION, ThreadContext.SECURITY)
                   .propagated(ThreadContext.ALL_REMAINING)
                   .build();

    CompletableFuture<Long> stage1 = executor.newIncompleteFuture();
    stage1.thenApply(function1)      // runs with captured context
          .thenApply(function2);     // runs with captured context
    stage1.completeAsync(supplier1); // runs with captured context
----

=== Apply thread context to a single CompletionStage action

[source, java]
----
    threadContext = ThreadContext.builder()
                        .propagated(ThreadContext.SECURITY)
                        .cleared(ThreadContext.ALL_REMAINING)
                        .build();

    Consumer<String> contextualConsumer = threadContext.contextualConsumer(s -> {
        ... do something that requires context
    });

    stage = invokeSomeMethodThatReturnsUnmanagedCompletionStage();
    stage.thenApply(function1)            // context is unpredictable
         .thenAccept(contextualConsumer); // runs with captured context
----

=== Reusable Context Snapshot

[source, java]
----
    threadContext = ThreadContext.builder().build();
    contextSnapshot = threadContext.currentContextExecutor();

    ... on some other thread,
    contextSnapshot.execute(() -> {
        ... do something that requires the previously captured context
    });
----

=== Transaction Usage Guidelines

For implementations that support propagation of JTA transactions, the following guidelines and examples demonstrate possible common usage patterns:

==== Run under the transaction of the executing thread

[source, java]
----
    threadContext = ThreadContext.builder()
                        .propagated(ThreadContext.APPLICATION)
                        .unchanged(ThreadContext.TRANSACTION)
                        .cleared(ThreadContext.ALL_REMAINING)
                        .build();

    Callable<Integer> updateDatabase = () -> {
        DataSource ds = InitialContext.doLookup("java:comp/env/ds1");
        try (Connection con = ds.getConnection()) {
            return con.createStatement().executeUpdate(sql);
        }
    });

    ... on some other thread,

    tx.begin();
    ... do transactional work
    updateDatabase.call(); // runs as part of the transaction
    ... more transactional work
    tx.commit();
----

==== Commit or rollback a transaction that has been propagated by a ManagedExecutor

If transaction demarcation is performed by a container then the only requirement is to avoid explicitly
terminating a transaction in dependent stages.

If transaction demarcation is performed by the application developer then the transaction should be
started before running any completion stages and should be terminated in a finally block after all
the stages have completed. The issue with ending the transaction in a completion stage is that
the context of the initiating thread will be re-applied after the executor finishes and if a stage
ended the transaction then this initiating thread will be associated with the finished transaction
which would mean that that thread could not begin any new transactions.
 
[source, java]
----

    ...

        // create an executor with transaction propagation enabled
        ManagedExecutor.builder()
                    .maxAsync(2)
                    .propagated(ThreadContext.TRANSACTION)
                    .cleared(ThreadContext.ALL_REMAINING)
                    .build();

        // look up a bean for starting and finishing transactions
        UserTransaction ut = CDI.current().select(UserTransaction.class).get();

        try {
            // enter transaction scope by starting a transaction
            ut.begin();

            // transaction scoped beans will be available
            int initialValue = transactionalService.getValue();

            // call a transactional bean on another thread to validate
            // that the transaction context propagates.
            CompletableFuture<Void> stage = executor.runAsync(
                () -> transactionalService.mandatory()); // will fail without a txn

            // wait for all stages to finish before ending the transaction
            stage.join();

            // we are still in transaction context so transaction scoped
            // beans will still be available
            Assert.assertEquals(initialValue + 1, transactionalService.getValue());
        }
        finally {
            // Must end the transaction in the same thread it was started from.
            // If it is ended by an executor thread then the transaction context
            // provider will re-associate the terminated transaction with the
            // initiating thread when the executor finishes which is undesirable.
            try {
                ut.commit();

                try {
                    // since there is now no active transaction, transaction scoped
                    // beans should no longer be available
                    transactionalService.getValue();
                    Assert.fail(
                        "TransactionScoped beans should only be available from transaction scope");
                }
                catch (Exception ignore) {
                    // expected since we are no longer in the scope of a transactions
                }
            }
            finally {
                // there should be no active transaction associated with the thread
                Assert.assertNull(ut.getStatus() != Status.STATUS_ACTIVE, "transaction still active");
            }
        }
----
